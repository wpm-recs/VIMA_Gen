"""
提取 vima_bench 关键代码（base.py, utils, components）供模型参考。
"""
from __future__ import annotations

import os
import sys

_THIS_DIR = os.path.dirname(os.path.abspath(__file__))
_ROOT_DIR = os.path.dirname(_THIS_DIR)
if _ROOT_DIR not in sys.path:
    sys.path.insert(0, _ROOT_DIR)


def get_code_reference_text() -> str:
    """
    提取并格式化关键代码参考，包括：
    - BaseTask 的关键方法（add_object_to_env, get_random_pose, is_match, etc.）
    - pybullet_utils 的函数签名和用法
    - misc_utils 的关键函数（invert, multiply, apply, euler/quat转换等）
    - PlaceholderObj 的用法
    - ObjEntry/TextureEntry 的定义
    """
    lines = [
        "========== BaseTask 关键方法参考 ==========",
        "",
        "# BaseTask.add_object_to_env 完整实现：",
        "def add_object_to_env(",
        "    self,",
        "    env,",
        "    obj_entry: ObjEntry,  # 从 ObjPedia.XXX.value 获取",
        "    color: TextureEntry,  # 从 TexturePedia.XXX.value 获取",
        "    size: tuple[float, float, float],",
        "    scalar: float | list[float] = 1.0,",
        "    pose: tuple[tuple, tuple] = None,  # (position, quaternion) 或 None 表示随机",
        "    category: str = 'rigid',",
        "    retain_temp: bool = True,",
        "    **kwargs,",
        ") -> tuple[int | None, str | None, tuple | None]:",
        "    \"\"\"",
        "    返回: (obj_id, urdf_path, pose)",
        "    如果失败返回 (None, urdf_path, pose)",
        "    \"\"\"",
        "    # 内部会调用 add_any_object, p_change_texture, add_object_id_reverse_mapping_info",
        "    # 使用后需要手动 append obj_id 到 env.obj_ids[category]",
        "",
        "# BaseTask.get_random_pose 用法：",
        "pose = self.get_random_pose(env, obj_size)  # 返回 (pos, quat) 或 (None, None)",
        "",
        "# BaseTask.is_match 用法：",
        "if self.is_match(obj_pose, target_pose, symmetry):",
        "    # 检查两个 pose 是否匹配（考虑对称性）",
        "",
        "# BaseTask.get_random_size 用法：",
        "size = self.get_random_size(obj_entry.size_range)",
        "",
        "# BaseTask 属性：",
        "self.bounds  # workspace bounds: np.array([[0.25, 0.75], [-0.5, 0.5], [0, 0.3]])",
        "self.rng  # np.random.default_rng(seed=seed)",
        "self.client_id  # env.client_id (在 reset 中设置)",
        "self.assets_root  # env.assets_root (在 reset 中设置)",
        "",
        "========== pybullet_utils 关键函数 ==========",
        "",
        "# add_any_object(env, obj_entry, pose, size, replace=None, retain_temp=False, category='rigid', scaling=1.0)",
        "# 返回: (obj_id, urdf_full_path)",
        "# 注意：会自动 append obj_id 到 env.obj_ids[category]",
        "",
        "# add_object_id_reverse_mapping_info(mapping_dict, obj_id, object_entry, texture_entry)",
        "# 必须调用：将 obj_id 映射到 object_entry 和 texture_entry 的信息",
        "# mapping_dict 通常是 env.obj_id_reverse_mapping",
        "",
        "# p_change_texture(obj_id, texture_entry, client_id)",
        "# 改变物体的纹理/颜色",
        "",
        "# if_in_hollow_object(test_object_poses, test_object_size, hollow_object_poses, hollow_object_size) -> bool",
        "# 检查 test_object 是否在 hollow_object（如 bowl）内",
        "",
        "========== misc_utils 关键函数 ==========",
        "",
        "# 位姿变换（pose 格式: (position, quaternion)）",
        "from vima_bench.tasks.utils import misc_utils as utils",
        "",
        "inverted_pose = utils.invert(pose)  # 返回 (pos, quat)",
        "combined_pose = utils.multiply(pose0, pose1)  # 组合两个位姿",
        "transformed_pos = utils.apply(pose, position)  # 将 position 变换到 pose 坐标系",
        "",
        "# 欧拉角与四元数转换",
        "quat = utils.eulerXYZ_to_quatXYZW((x, y, z))  # 欧拉角 -> 四元数 (xyzw)",
        "euler = utils.quatXYZW_to_eulerXYZ(quat)  # 四元数 -> 欧拉角 (xyz)",
        "",
        "# 采样",
        "pixel = utils.sample_distribution(prob=np.float32(prob_matrix), rng=self.rng)",
        "",
        "# 坐标转换",
        "xyz = utils.pix_to_xyz(pixel, heightmap, bounds, pixel_size)",
        "pixel = utils.xyz_to_pix(position, bounds, pixel_size)",
        "",
        "========== PlaceholderObj 用法 ==========",
        "",
        "from vima_bench.tasks.components.placeholders import PlaceholderObj",
        "",
        "# 在 reset() 中创建 placeholder：",
        "self.placeholders['dragged_obj'] = PlaceholderObj(",
        "    name=obj_entry.name,",
        "    obj_id=obj_id,",
        "    urdf=urdf_path,",
        "    novel_name=obj_entry.novel_name,",
        "    alias=obj_entry.alias,",
        "    color=texture_entry,  # TextureEntry",
        "    image_size=self._placeholder_img_size,",
        "    seed=self.seed,",
        ")",
        "",
        "========== ObjEntry / TextureEntry 结构 ==========",
        "",
        "# ObjEntry (NamedTuple):",
        "#   name: str",
        "#   assets: str  # URDF 路径",
        "#   size_range: SizeRange(low=(x,y,z), high=(x,y,z))",
        "#   from_template: bool",
        "#   symmetry: float | None  # 旋转对称角度（弧度）",
        "#   alias: list[str] | None",
        "#   novel_name: list[str] | None",
        "",
        "# TextureEntry (NamedTuple):",
        "#   name: str",
        "#   color_value: tuple[float, float, float] | None  # RGB",
        "#   texture_asset: str | None  # 纹理图片路径",
        "",
        "# 获取 entry：",
        "obj_entry = ObjPedia.BOWL.value  # 或 ObjPedia.BLOCK.value 等",
        "texture_entry = TexturePedia.RED.value  # 或 TexturePedia.lookup_color_by_name('red')",
        "",
        "# 从 size_range 采样大小：",
        "size = self.get_random_size(obj_entry.size_range)",
        "",
        "========== 典型 reset() 流程 ==========",
        "",
        "def reset(self, env):",
        "    super().reset(env)  # 必须调用",
        "",
        "    # 1. 采样物体和纹理",
        "    obj_entry = self.rng.choice(self.possible_dragged_obj).value",
        "    texture_entry = self.rng.choice(self.possible_dragged_obj_texture).value",
        "    size = self.get_random_size(obj_entry.size_range)",
        "",
        "    # 2. 添加物体到环境",
        "    obj_id, urdf_path, pose = self.add_object_to_env(",
        "        env, obj_entry, texture_entry, size, category='rigid'",
        "    )",
        "    if obj_id is None:",
        "        raise ValueError('Failed to add object')",
        "",
        "    # 3. 添加到 env.obj_ids",
        "    env.obj_ids['rigid'].append(obj_id)",
        "",
        "    # 4. 创建 placeholder（如果需要在 prompt 中显示）",
        "    self.placeholders['dragged_obj'] = PlaceholderObj(",
        "        name=obj_entry.name, obj_id=obj_id, urdf=urdf_path,",
        "        color=texture_entry, image_size=self._placeholder_img_size, seed=self.seed",
        "    )",
        "",
        "    # 5. 设置 goals",
        "    target_pose = (target_pos, target_quat)",
        "    self.goals.append((",
        "        [(obj_id, (obj_entry.symmetry, None))],  # objs",
        "        np.ones((1, 1)),  # matches",
        "        [target_pose],  # targs",
        "        False,  # replace",
        "        True,  # rotations",
        "        'pose',  # metric",
        "        None,  # params",
        "        1.0,  # max_progress",
        "    ))",
        "    self._all_goals = self.goals.copy()",
        "",
        "========== check_success 典型实现 ==========",
        "",
        "def check_success(self, *args, **kwargs) -> ResultTuple:",
        "    from vima_bench.tasks.task_suite.base import ResultTuple",
        "    import pybullet as p",
        "",
        "    # 检查所有 goals 是否完成",
        "    if len(self.goals) == 0:",
        "        return ResultTuple(success=True, failure=False)",
        "",
        "    # 检查是否有物体在工作空间外（失败）",
        "    for goal in self.goals:",
        "        objs, _, _, _, _, _, _, _ = goal",
        "        for obj_id_packed in objs:",
        "            obj_id, _ = obj_id_packed",
        "            pose = p.getBasePositionAndOrientation(obj_id, physicsClientId=self.client_id)",
        "            if not self._valid_workspace.contains(np.array(pose[0][:2])):",
        "                return ResultTuple(success=False, failure=True)",
        "",
        "    return ResultTuple(success=False, failure=False)",
        "",
    ]
    return "\n".join(lines)
